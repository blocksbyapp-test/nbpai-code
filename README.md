# Simplified Schema Example

This is a simplified schema to demonstrate how operations are generated by the graphql-compose-mongoose plugin for models.

## Example Model Schema

```graphql
type User {
  _id: MongoID!
  name: String
  email: String
  createdAt: Date
  updatedAt: Date
}

## Generated Queries

- `UserById(_id: MongoID!): User`
- `UserOne(filter: FilterFindOneUserInput, skip: Int, sort: SortFindOneUserInput): User`
- `UserMany(filter: FilterFindManyUserInput, skip: Int, limit: Int, sort: SortFindManyUserInput): [User!]`
- `UserCount(filter: FilterCountUserInput): Int`

## Generated Mutations

- `UserCreateOne(record: CreateOneUserInput!): CreateOneUserPayload`
- `UserUpdateById(_id: MongoID!, record: UpdateByIdUserInput!): UpdateByIdUserPayload`
- `UserRemoveById(_id: MongoID!): RemoveByIdUserPayload`
```
This schema is automatically generated based on the Mongoose model definitions in `src/features/core/server/services/mongoose.ts` using the graphql-compose-mongoose plugin. The plugin provides a set of standard CRUD operations for each model, reducing the need for manual GraphQL schema and resolver definitions.

# Developer Guide: Building New SaaS Features

## 1. Project Setup and Initial Deployment

Before diving into development, ensure your environment is set up and the project is deployed.

1.  Create a MongoDB account and get a connection string.
2.  Have a GitHub repository with a private access token.
3.  Create an AWS account and configure CLI access.
4.  Rename `deployment/params.json.placeholder` to `deployment/params.json`.
5.  Provide values in `deployment/params.json`:

    ```json
    [
      {
        "ParameterKey": "NextPublicGoogleGaTag",
        "ParameterValue": "G-XXXXXXXXX"
      },
      {
        "ParameterKey": "NextPublicDBPassword",
        "ParameterValue": "your_db_password"
      },
      {
        "ParameterKey": "NextPublicDBUsername",
        "ParameterValue": "your_db_username"
      },
      {
        "ParameterKey": "NextPublicDBHost",
        "ParameterValue": "your_mongodb_host.mongodb.net"
      },
      {
        "ParameterKey": "NextPublicDBPort",
        "ParameterValue": "27017"
      },
      {
        "ParameterKey": "AppName",
        "ParameterValue": "YourAppName"
      },
      {
        "ParameterKey": "EnvironmentName",
        "ParameterValue": "main"
      },
      {
        "ParameterKey": "RepositoryUrl",
        "ParameterValue": "https://github.com/your_username/your_repo.git"
      },
      {
        "ParameterKey": "GithubAccessToken",
        "ParameterValue": "ghp_your_github_access_token"
      },
      {
        "ParameterKey": "NextPublicAuthSecret",
        "ParameterValue": "a_strong_random_secret_for_nextauth"
      },
      {
        "ParameterKey": "NextPublicAuthGoogleId",
        "ParameterValue": "your_google_client_id"
      },
      {
        "ParameterKey": "NextPublicAuthGoogleSecret",
        "ParameterValue": "your_google_client_secret"
      },
      {
        "ParameterKey": "NextPublicStripeSecretKey",
        "ParameterValue": "sk_test_your_stripe_secret_key"
      },
      {
        "ParameterKey": "NextPublicStripeWebhookSecret",
        "ParameterValue": "whsec_your_stripe_webhook_secret"
      },
      {
        "ParameterKey": "CustomDomainName",
        "ParameterValue": "yourdomain.com"
      }
    ]
    ```

6.  Run the AWS CloudFormation deployment command:

    ```bash
    aws cloudformation deploy --template-file deployment/deploy-aws.yaml --stack-name nextboilerplateai-stack --parameter-overrides file://deployment/params.json --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
    ```

7.  Commit and push your code to trigger the deployment.

### Generate a Personal Access Token (PAT) for GitHub

This PAT is used by Amplify for repository access:

1.  Sign in to your GitHub account.
2.  In the upper right corner, click your profile photo and choose `Settings`.
3.  In the left navigation menu, choose `Developer settings`.
4.  On the GitHub Apps page, in the left navigation menu, choose `Personal access tokens`.
5.  Choose `Generate new token`.
6.  For `Note`, enter a descriptive name for the token.
7.  In the `Select scopes` section, select `admin:repo_hook` + `repo`.
8.  Choose `Generate token`.

## 2. Understanding the Project Structure

The project is organized into `features`, with `core` providing shared functionalities and other directories representing distinct SaaS features (e.g., `panel`, `my-feature`).

Each feature module (e.g., `my-feature`, `panel`) contains both client-side and server-side logic. The server-side logic is further divided into `private` and `public` GraphQL API endpoints, defined in `src/features/[feature]/server/private.ts` and `src/features/[feature]/server/public.ts` respectively. This distinction is crucial for security and access control, as the `middleware.ts` file handles authentication for these routes.

```
src/
├── app/                  # Next.js App Router pages and API routes
│   ├── api/              # Global API routes (e.g., NextAuth)
│   ├── core/             # Example page for Radix UI components
│   ├── my-feature/       # Pages and API routes for 'my-feature'
│   ├── panel/            # Pages and API routes for 'panel'
│       ├── api/          # private api route for panel
│       └── public/       # public Pages for 'panel' 
│           └── api/      # public API  for 'panel' 
├── features/             # Core logic and feature modules
│   ├── core/             # Reusable components, services, models, types
│   │   ├── client/       # Client-side core components (e.g., ApolloWrapper, Auth forms)
│   │   ├── config/       # Environment configuration
│   │   ├── server/       # Server-side core services (e.g., auth, mongoose, stripe)
│   │   └── types/        # Shared TypeScript types
│   ├── my-feature/       # Example feature module
│   │   ├── client/       # Client-side components/pages for 'my-feature'
│   │   ├── graphql/      # GraphQL queries/mutations for 'my-feature'
│   │   ├── server/       # Server-side logic for 'my-feature'
│   │   └── types/        # TypeScript types for 'my-feature'
│   └── panel/            # User panel feature module
│       ├── client/       # Client-side components/pages for 'panel'
│       ├── graphql/      # GraphQL queries/mutations for 'panel'
│       ├── server/       # Server-side logic for 'panel'
│       └── types/        # TypeScript types for 'panel'
├── generated/            # Auto-generated GraphQL types and hooks (DO NOT EDIT)
├── styles/               # Global styles
├── templates/            # Email templates
└── ...
```

### `src/features/index.ts`

This file defines the `SUPPORTED_FEATURES` array, which is crucial for the dynamic routing and authentication middleware. When you create a new feature, you must add its name to this array.

```typescript
// src/features/index.ts
export const SUPPORTED_FEATURES = ['panel', 'my-feature'] as const;
export type SupportedFeature = (typeof SUPPORTED_FEATURES)[number];
```

## 3. Running Project Commands

The `package.json` defines several scripts to help with development:

```json
{
  "scripts": {
    "gql": "npx env-cmd -f \".env.local\" node scripts/generate-ts-from-schema.mjs",
    "dev": " npx env-cmd -f \".env.local\" next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  }
}
```

*   `npm run dev`: Starts the Next.js development server. It uses `env-cmd` to load environment variables from `.env.local`.
*   `npm run build`: Builds the Next.js application for production.
*   `npm run start`: Starts the Next.js production server.
*   `npm run lint`: Runs ESLint to check for code quality issues.
*   `npm run gql`: **Crucial for GraphQL development.** This command generates TypeScript types and Apollo hooks from your GraphQL schema. It connects to your running development server (`http://127.0.0.1:3000/my-feature/api` by default, configured in `codegen.yml`) to introspect the schema. **Always run this command after making changes to your GraphQL models or resolvers.**

## 4. Authentication and Authorization

This boilerplate uses `next-auth` for authentication, integrated with a custom credentials provider and Google OAuth. The `core` module handles the underlying logic.

### Declaring Auth Routes

Each feature can have its own authentication routes. The main NextAuth API route is global, but credential verification is feature-specific.

*   **Global NextAuth API Route (`src/app/api/auth/[...nextauth]/route.ts`):**

    ```typescript
    // src/app/api/auth/[...nextauth]/route.ts
    import { getHandlers } from '@/features/core/server/services/auth';

    export const { GET, POST } = await getHandlers();
    ```

    This route exposes the NextAuth API endpoints (e.g., `/api/auth/signin`, `/api/auth/callback/google`). The Google Auth Provider can work across all features, and the session is shared across them.

*   **Feature-Specific Credential Verification (`src/app/[feature]/auth/verify-credentials/route.ts`):**

    Each feature that uses credential-based login needs a route to verify user credentials against its specific `User` model.

    ```typescript
    // src/app/panel/auth/verify-credentials/route.ts
    import { createVerifyCredentialsRoute } from '@/features/core/server/routes/auth/verify-credentials/route';
    import { User } from '@/features/panel/server/models/User'; // Import your feature's User model

    const { POST } = createVerifyCredentialsRoute(User);

    export { POST };
    ```

    The `createVerifyCredentialsRoute` function from `core` abstracts the logic for checking email/password against a Mongoose `User` model.

### Authentication Middleware

`src/middleware.ts` protects routes based on the feature. It checks if a user is authenticated for a given feature before allowing access to private routes.

```typescript
// src/middleware.ts (simplified)
import { SUPPORTED_FEATURES, type SupportedFeature } from '@/features';
import { createAuthForFeature } from '@/features/core/server/services/auth';
import type { NextRequest } from 'next/server';
import { NextResponse } from 'next/server';

export default async function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;

  const seg1 = (pathname.split('/')[1] || '') as string;
  const isSupported = (SUPPORTED_FEATURES as readonly string[]).includes(seg1);
  if (!isSupported) {
    return NextResponse.next(); // Allow access to non-feature routes
  }

  // Public routes for the feature (e.g., /panel/public/api, /panel/auth/signin)
  if (
    pathname.startsWith(`/${seg1}/public`) ||
    pathname.startsWith(`/${seg1}/auth`)
  ) {
    return NextResponse.next();
  }

  // For private routes, check authentication
  const { auth } = createAuthForFeature(seg1 as SupportedFeature);
  const session = await auth();
  if (!session) {
    return NextResponse.redirect(new URL('/' + seg1 + '/auth/signin', req.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)',
  ],
};
```

## 5. GraphQL API with Mongoose

This boilerplate uses `graphql-compose-mongoose` to automatically generate GraphQL types and resolvers from your Mongoose models, significantly reducing boilerplate code. **Always run `npm run gql` after making changes to your GraphQL models or resolvers.**

### Defining Mongoose Models

Models are defined within each feature's `server/models` directory. The `createMongooseModel` helper from `core` simplifies model creation and GraphQL integration.

```typescript
// src/features/my-feature/server/models/Item.ts
import { createMongooseModel } from '@/features/core/server/services/mongoose';
import mongoose from 'mongoose';

export const itemSchema = new mongoose.Schema(
  {
    name: String,
    email: String,
    status: { type: String, default: 'todo' },
  },
  {
    timestamps: true,
  },
);

// This call creates the Mongoose model, its GraphQL TypeComposer (ItemTC),
// and pre-generated query/mutation resolvers (ItemQueries, ItemMutations).
export const { Item, ItemTC, ItemMutations, ItemQueries } = createMongooseModel(
  'my-feature', // The database name (feature name)
  'Item',       // The model name
  itemSchema,   // The Mongoose schema
);
```

### Declaring Queries and Mutations

GraphQL API routes are defined using `createGraphqlServer` from `core`.

*   **Private Apollo Server (`src/app/[feature]/api/route.ts`):**

    This server is protected by the middleware and requires authentication.

    ```typescript
    // src/app/my-feature/api/route.ts
    import { createGraphqlServer } from '@/features/core/server/services/graphqlServer';
    import {
      ItemMutations,
      ItemQueries,
      ItemTC,
    } from '@/features/my-feature/server/models/Item';
    // ... other imports for custom resolvers/types

    const { POST, GET, dynamic } = createGraphqlServer({
      query: {
        // Automatically generated queries for the Item model
        ...ItemQueries(['ItemMany']), // Exposes ItemMany query
        // ... add custom queries here
      },
      mutation: {
        // Automatically generated mutations for the Item model
        ...ItemMutations(['ItemCreateOne', 'ItemRemoveById', 'ItemUpdateById']), // Exposes CRUD mutations
        // ... add custom mutations here
      },
      models: [ItemTC], // Register TypeComposers for schema generation (just includes the interface)
    });

    export { dynamic, GET, POST };
    ```

    The `ItemQueries` and `ItemMutations` helpers allow you to select which auto-generated resolvers you want to expose. For example, `ItemQueries(['ItemMany'])` will only expose the `ItemMany` query.

*   **Public Apollo Server (`src/app/[feature]/public/api/route.ts`):**

    This server is publicly accessible and does not require authentication. It's suitable for sign-up, password reset, or public data.

    ```typescript
    // src/app/panel/public/api/route.ts
    import { sendEmailFromLocalTemplate } from '@/features/core/server/services/emailService';
    import { createGraphqlServer } from '@/features/core/server/services/graphqlServer';
    import { createUserPasswordOperations } from '@/features/core/server/services/userPasswordOperations';
    import { PasswordResetToken } from '@/features/panel/server/models/PasswordResetToken';
    import { User, UserTC } from '@/features/panel/server/models/User';

    const { query: passwordQuery, mutation: passwordMutation } =
      createUserPasswordOperations(User, PasswordResetToken, 'panel');

    const { POST, GET, dynamic } = createGraphqlServer({
      query: {
        ...passwordQuery, // Exposes validatePasswordResetToken query
      },
      mutation: {
        // Exposes UserCreateOne mutation, with a custom wrapper to send a welcome email
        UserCreateOne: UserTC.mongooseResolvers
          .createOne()
          .wrapResolve((next) => async (rp) => {
            const payload = await next(rp);
            if (payload.record) {
              const { name, email } = payload.record;
              await sendEmailFromLocalTemplate(
                'RegistrationEmail',
                { name: name || email },
                email,
              );
            }
            return payload;
          }),
        ...passwordMutation, // Exposes requestPasswordReset and resetPassword mutations
      },
      models: [],
    });

    export { dynamic, GET, POST };
    ```

### Custom Resolvers

You can define custom resolvers for more complex logic not covered by auto-generated CRUD operations.

```typescript
// src/features/my-feature/server/resolvers/exampleMutation.ts
import type { Resolver } from '@/features/core/server/types/types';
import { Item } from '@/features/my-feature/server/models/Item';
import { exampleService } from '@/features/my-feature/server/services/exampleService';

export const exampleMutation: Resolver<any, any> = async (
  parent,
  args,
  context,
) => {
  try {
    const { name } = args.input;
    const item = new Item({
      name: exampleService(name), // Use a custom service
    });
    await item.save();
    return { name };
  } catch (err) {
    console.log({ err });
    throw err;
  }
};
```

## 6. Payments with Stripe

This boilerplate provides a robust integration with Stripe for managing subscriptions and one-time purchases.

### Stripe Database Adapters

The `StripeDatabaseAdapters` interface defines how Stripe interacts with your Mongoose models. You need to implement these adapters for each feature that uses payments.

```typescript
// src/features/panel/server/services/stripeDatabaseAdapters.ts
import { createStripeDatabaseAdapters } from '@/features/core/server/services/createStripeDatabaseAdapters';
import { sendEmailFromLocalTemplate } from '@/features/core/server/services/emailService';
import { Team } from '@/features/panel/server/models/Team';
import { User } from '@/features/panel/server/models/User';

export const panelStripeAdapters = createStripeDatabaseAdapters(
  User, // Your feature's User model
  Team, // Your feature's Team model
  async (email, name) => { // Optional: Callback for user creation (e.g., send welcome email)
    await sendEmailFromLocalTemplate(
      'RegistrationEmail',
      { name: name || email },
      email,
    );
  },
);
```

### Exposing Payments Operations via GraphQL

The `createPaymentsOperations` function from `core` generates GraphQL queries and mutations for Stripe functionalities.

```typescript
// src/features/panel/server/private.ts (snippet)
import { createPaymentsOperations } from '@/features/core/server/services/createPaymentsOperations';
import { panelStripeAdapters } from './services/stripeDatabaseAdapters';

const { query: paymentsQuery, mutation: paymentsMutation } =
  createPaymentsOperations(panelStripeAdapters, 'panel'); // Pass your feature's adapters and name

const { POST, GET, dynamic } = createGraphqlServer({
  query: {
    ...paymentsQuery, // Exposes stripePrices, stripeProducts, currentUserStripeSubscriptionId, etc.
    // ... other queries
  },
  mutation: {
    ...paymentsMutation, // Exposes createCheckoutSession, createCustomerPortalSession
    // ... other mutations
  },
  // ...
});
```

### Stripe Checkout Route

After a successful Stripe checkout, the user is redirected to a specific route to process the payment details and update the database.

```typescript
// src/app/panel/public/stripe/checkout/route.ts
import { createStripeCheckoutRoute } from '@/features/core/server/routes/stripe/checkout/route';
import { panelStripeAdapters } from '@/features/panel/server/services/stripeDatabaseAdapters';

const { GET } = createStripeCheckoutRoute(panelStripeAdapters, 'panel');

export { GET };
```

### Stripe Webhooks

Stripe webhooks are essential for handling asynchronous events (e.g., subscription changes, refunds). The boilerplate provides a helper to set up your webhook endpoint.

```typescript
// src/app/panel/public/stripe/webhook/route.ts
import { createStripeWebhookRoute } from '@/features/core/server/routes/stripe/webhook/route';
import { panelStripeAdapters } from '@/features/panel/server/services/stripeDatabaseAdapters';

const { POST } = createStripeWebhookRoute(panelStripeAdapters);

export { POST };
```

**Important:** Remember to configure your Stripe webhook in the Stripe Dashboard to point to `YOUR_APP_URL/[feature]/public/stripe/webhook` and include the `checkout.session.completed`, `customer.subscription.updated`, `customer.subscription.deleted`, `charge.refunded`, `charge.dispute.created`, and `charge.dispute.closed` events.

## 7. Consuming Generated Apollo Hooks in React

After running `npm run gql`, the `src/generated/types.ts`, `src/features/[feature]/generated/types.ts`, `src/features/[feature]/generated/public/types.ts`, and `src/features/[feature]/generated/operations.ts` files will contain TypeScript types and React hooks (e.g., `useQuery`, `useMutation`) for your GraphQL operations. **Do not edit these files directly.**

### Example: Using `useQuery` and `useMutation`

```typescript
// src/features/my-feature/client/components/TodoList.tsx (simplified)
'use client';
import {
  useItemCreateOneMutation,
  useItemManyQuery,
  useItemRemoveByIdMutation,
  useItemUpdateByIdMutation,
} from '@/features/my-feature/generated/types'; // Import generated hooks
import { useSession } from 'next-auth/react';
import { useEffect, useState } from 'react';

export const TodoList = () => {
  const { data: session } = useSession();
  const [newItemName, setNewItemName] = useState('');

  // Use the generated useItemManyQuery hook to fetch data
  const { data, loading, error, refetch } = useItemManyQuery({
    variables: { filter: { email: session?.user?.email } },
    skip: !session?.user?.email, // Skip query if user email is not available
  });

  // Use the generated useItemCreateOneMutation hook for creating items
  const [createItem] = useItemCreateOneMutation();
  const [removeItem] = useItemRemoveByIdMutation();
  const [updateItem] = useItemUpdateByIdMutation();

  // ... (state and effects to process fetched data)

  const handleAddItem = async () => {
    if (!newItemName.trim() || !session?.user?.email) return;
    await createItem({
      variables: {
        record: {
          name: newItemName,
          email: session.user.email,
          status: 'todo',
        },
      },
    });
    setNewItemName('');
    await refetch(); // Refetch data after mutation
  };

  const handleDeleteItem = async (id: string) => {
    await removeItem({ variables: { _id: id } });
    await refetch();
  };

  const handleCardDrop = async (
    draggedCard: any,
    sourceColumnId: string,
    targetColumnId: string,
  ) => {
    // ... UI state update logic ...

    try {
      await updateItem({
        variables: {
          _id: draggedCard.id,
          record: {
            status: targetColumnId,
          },
        },
      });
    } catch (e) {
      console.error('Failed to update item status on backend', e);
      await refetch(); // Revert UI or refetch on error
    }
  };

  if (loading) return <div className="text-white">Loading...</div>;
  if (error) return <div className="text-white">Error: {error.message}</div>;

  // ... render UI ...
};
```

### Apollo Client Setup

The `ApolloWrapper` in `src/features/core/client/components/ApolloWrapper.tsx` dynamically determines the correct GraphQL endpoint based on the current URL path (e.g., `/panel/api` or `/my-feature/api`).

For public API calls (e.g., sign-in, password reset), use `PublicApolloClient` to explicitly target the public endpoint:

```typescript
// src/app/panel/auth/signin/page.tsx (snippet)
'use client';
import { PublicApolloClient } from '@/features/core/client/components/ApolloWrapper';
import { useUserCreateOneMutation } from '@/features/panel/generated/public/types';

const panelAuthClient = new PublicApolloClient('panel'); // Target the 'panel' feature's public API

export default () => {
  const [createUser, { loading: registerLoading, error: registerError }] =
    useUserCreateOneMutation({
      client: panelAuthClient, // Use the public client for this mutation
    });

  // ...
};
```

## 8. Code Structure for New Features

When creating a new feature, follow the existing `my-feature` or `panel` structure:

*   **`src/features/[your-feature-name]/`**
    *   **`client/`**: React components, pages, and client-side logic.
        *   `components/`: Reusable UI components.
        *   `pages/`: Next.js client components that act as full pages.
    *   **`graphql/`**: `.graphql` files containing your GraphQL queries and mutations. These are used by `npm run gql`.
    *   **`server/`**: Node.js server-side logic.
        *   `models/`: Mongoose model definitions.
        *   `resolvers/`: Custom GraphQL resolver functions.
        *   `services/`: Business logic, external API integrations, etc.
        *   `private.ts`: Defines the private (authenticated) GraphQL API for your feature.
        *   `public.ts`: Defines the public (unauthenticated) GraphQL API for your feature.
        *   `services/stripeDatabaseAdapters.ts`: If your feature uses payments, this file will contain the Stripe database adapters.
    *   **`types/`**: TypeScript types specific to your feature, including GraphQL input/output types if you define custom ones.

*   **`src/app/[your-feature-name]/`**
    *   `page.tsx`: The main entry point for your feature's UI.
    *   `api/route.ts`: Imports and exports the private GraphQL API from `src/features/[your-feature-name]/server/private.ts`.
    *   `public/api/route.ts`: Imports and exports the public GraphQL API from `src/features/[your-feature-name]/server/public.ts`.
    *   `auth/signin/page.tsx`: If your feature has a dedicated sign-in page.
    *   `auth/verify-credentials/route.ts`: If your feature uses credential-based authentication.

## 9. Radix UI Components and Theme (`src/app/core/page.tsx`)

The `src/app/core/page.tsx` file serves as a comprehensive showcase for various Radix UI components and their integration with the application's theming. Radix UI is a low-level UI component library that provides unstyled, accessible components, allowing for full control over styling. This page demonstrates how to use components like `Button`, `TextField`, `Dialog`, `DropdownMenu`, `Tooltip`, `Callout`, `Switch`, `Slider`, `Table`, `Progress`, and more.

It also highlights the application's theming capabilities, primarily managed through `@radix-ui/themes`, which provides a set of pre-built, opinionated components and a theming system on top of Radix UI primitives. This allows for consistent styling and a cohesive user experience across the application.

By following this structure and leveraging the `core` utilities, you can rapidly build and extend your SaaS application with new functionalities.

## Deployments

# CREATE
aws cloudformation create-stack --stack-name nextboilerplateai-stack --template-body file://deployment/deploy-aws.yaml --parameters file://deployment/params.json --capabilities CAPABILITY_IAM

# DELETE
aws cloudformation delete-stack --stack-name nextboilerplateai-stack
**WARNING**: This command will permanently delete your application and all associated resources from AWS.

# UPDATE
aws cloudformation update-stack --stack-name nextboilerplateai-stack --template-body file://deployment/deploy-aws.yaml --parameters file://deployment/params.json --capabilities CAPABILITY_IAM
**NOTE**: Run this command if you have added new environment variables or made changes to the `deploy-aws.yaml` CloudFormation template.

## Environment Variables

This section provides a complete guide on how to manage environment variables in this project, covering both local development and AWS Amplify deployments.

### Naming Convention

All environment variables intended for use in the WEB_COMPUTE runtime must be prefixed with `NEXT_PUBLIC_`. Variables without this prefix will not be available in the runtime
Don't worry, the secrets used on server side will not be available in the client side, unless you explicitly reference them in the client code
### Step-by-Step Guide to Adding/Modifying an Environment Variable

Let's say you want to add a new environment variable called `MY_NEW_VARIABLE`.

#### 1. For Local Development (`.env.local`)

For local development, environment variables are loaded from the `.env.local` file. This file should **not** be committed to version control.

*   **Create/Open**: If it doesn't exist, create a file named `.env.local` in the root of your project.
*   **Add/Modify Variable**: Add your variable to this file. Remember the `NEXT_PUBLIC_` prefix if it's for the client-side.

    ```dotenv
    # .env.local
    NEXT_PUBLIC_MY_NEW_VARIABLE="your_local_value"
    ```

*   **Restart Development Server**: After modifying `.env.local`, you must restart your Next.js development server (`npm run dev`) for the changes to take effect.

#### 2. For AWS Amplify Deployment (`deployment/params.json` and `deployment/deploy-aws.yaml`)

For production deployments via AWS CloudFormation (which sets up AWS Amplify), environment variables need to be declared in two places:

##### a. `deployment/params.json`

This file holds the actual values for your environment variables that will be passed to the CloudFormation stack.

*   **Open**: Open `deployment/params.json`.
*   **Add ParameterKey and ParameterValue**: Add a new JSON object to the array for your variable. The `ParameterKey` should match the name you'll use in `deploy-aws.yaml` (typically the variable name without the `NEXT_PUBLIC_` prefix, but it's a convention, not a strict rule for `ParameterKey`). The `ParameterValue` is the actual secret or configuration value.

    ```json
    [
      // ... existing parameters
      {
        "ParameterKey": "NextPublicMyNewVariable",
        "ParameterValue": "your_production_value"
      }
    ]
    ```

    **Note**: The `ParameterKey` here is often camelCase or PascalCase, but the actual environment variable name in the application will be uppercase with underscores (e.g., `NEXT_PUBLIC_MY_NEW_VARIABLE`). CloudFormation handles this mapping.

##### b. `deployment/deploy-aws.yaml`

This CloudFormation template defines the AWS resources, including the Amplify application and its environment variables. You need to explicitly tell Amplify to expose these variables.

*   **Open**: Open `deployment/deploy-aws.yaml`.
*   **Locate AmplifyApp Resource**: Find the `AmplifyApp` resource
*   **Add to EnvironmentVariables**: Under the `Properties` section of `AmplifyApp`, locate `EnvironmentVariables`. Add your new variable here, referencing the `ParameterKey` from `params.json`.

    ```yaml
    # deployment/deploy-aws.yaml (snippet)
    Parameters:
      # ... existing parameters
      NextPublicMyNewVariable:
        Type: String

    # ... other properties
    Resources:
      AmplifyApp:
        Type: AWS::Amplify::App
        Properties:
          # ... other properties
          EnvironmentVariables:
            # ... existing environment variables
            NEXT_PUBLIC_MY_NEW_VARIABLE: !Ref NextPublicMyNewVariable # Reference the ParameterKey
            # IMPORTANT: Variables need to have NEXT_PUBLIC_ prefix otherwise they're not exposed to the WEB_COMPUTE build.
          # ... other properties
    ```

*   **Update Deployment**: After modifying both `params.json` and `deploy-aws.yaml`, run the CloudFormation update command:

    ```bash
    aws cloudformation update-stack --stack-name nextboilerplateai-stack --template-body file://deployment/deploy-aws.yaml --parameters file://deployment/params.json --capabilities CAPABILITY_IAM
    ```

#### 3. Application Configuration (`src/features/core/config/index.ts`)

To make your environment variables easily accessible and type-safe within your application code, you should add them to the central configuration file.

*   **Open**: Open `src/features/core/config/index.ts`.
*   **Add to Exported Object**: Add your new variable to the default exported object, ensuring it's typed correctly.

    ```typescript
    // src/features/core/config/index.ts
    import * as process from 'process';

    export default {
      // ... existing variables
      myNewVariable: process.env.NEXT_PUBLIC_MY_NEW_VARIABLE as string,
    };
    ```

By following these steps, you ensure your environment variables are correctly configured for both local development and production deployment, and are accessible within your application code.
